{
  "posts": [
    {
      "id": 1,
      "title": "json-server",
      "author": "typicode",
      "content": "abc def ghi jkl"
    },
    {
      "id": 2,
      "title": "title2",
      "author": "typicode",
      "content": "lorep ipsum blablabla"
    },
    {
      "title": "titlleeeee",
      "author": "sadfghnbvc",
      "content": "sdfgnbvc",
      "id": 3
    },
    {
      "title": "vvv",
      "author": "vvv",
      "content": "vvvv",
      "id": 4
    },
    {
      "title": "bbbb",
      "author": "bbbb",
      "content": "bbbbbb",
      "id": 5
    },
    {
      "title": "nnn",
      "author": "nnnn",
      "content": "nnn",
      "id": 6
    },
    {
      "title": "cccc",
      "author": "cccc",
      "content": "ccccc",
      "id": 7
    },
    {
      "title": "bvcvswqqq",
      "author": "qqqqqdddddd",
      "content": "ddddddddddsd sda   !!!!!",
      "id": 8
    },
    {
      "title": "bbbccccccc",
      "author": "ccccccccccccc",
      "content": "ccccccccccccccc",
      "id": 9
    },
    {
      "title": "typescript documentation",
      "author": "not me",
      "content": "TypeScript provides several utility types to facilitate common type transformations. These utilities are available globally.\n\nAwaited<Type>\nReleased: 4.5\n\nThis type is meant to model operations like await in async functions, or the .then() method on Promises - specifically, the way that they recursively unwrap Promises.\n\nExample\ntype A = Awaited<Promise<string>>;\n    \ntype A = string\n \ntype B = Awaited<Promise<Promise<number>>>;\n    \ntype B = number\n \ntype C = Awaited<boolean | Promise<number>>;\n    \ntype C = number | boolean\nTry\nPartial<Type>\nReleased:\n2.1\n\nConstructs a type with all properties of Type set to optional. This utility will return a type that represents all subsets of a given type.\n\nExample\ninterface Todo {\n  title: string;\n  description: string;\n}\n \nfunction updateTodo(todo: Todo, fieldsToUpdate: Partial<Todo>) {\n  return { ...todo, ...fieldsToUpdate };\n}\n \nconst todo1 = {\n  title: \"organize desk\",\n  description: \"clear clutter\",\n};\n \nconst todo2 = updateTodo(todo1, {\n  description: \"throw out trash\",\n});\nTry\nRequired<Type>\nReleased:\n2.8\n\nConstructs a type consisting of all properties of Type set to required. The opposite of Partial.\n\nExample\ninterface Props {\n  a?: number;\n  b?: string;\n}\n \nconst obj: Props = { a: 5 };\n \nconst obj2: Required<Props> = { a: 5 };\nProperty 'b' is missing in type '{ a: number; }' but required in type 'Required<Props>'.\nTry\nReadonly<Type>\nReleased:\n2.1\n\nConstructs a type with all properties of Type set to readonly, meaning the properties of the constructed type cannot be reassigned.\n\nExample\ninterface Todo {\n  title: string;\n}\n \nconst todo: Readonly<Todo> = {\n  title: \"Delete inactive users\",\n};\n \ntodo.title = \"Hello\";\nCannot assign to 'title' because it is a read-only property.\nTry\nThis utility is useful for representing assignment expressions that will fail at runtime (i.e. when attempting to reassign properties of a frozen object).\n\nObject.freeze\nfunction freeze<Type>(obj: Type): Readonly<Type>;\nRecord<Keys, Type>\nReleased:\n2.1\n\nConstructs an object type whose property keys are Keys and whose property values are Type. This utility can be used to map the properties of a type to another type.\n\nExample\ninterface CatInfo {\n  age: number;\n  breed: string;\n}\n \ntype CatName = \"miffy\" | \"boris\" | \"mordred\";\n \nconst cats: Record<CatName, CatInfo> = {\n  miffy: { age: 10, breed: \"Persian\" },\n  boris: { age: 5, breed: \"Maine Coon\" },\n  mordred: { age: 16, breed: \"British Shorthair\" },\n};\n \ncats.boris;\n \nconst cats: Record<CatName, CatInfo>\nTry\nPick<Type, Keys>\nReleased:\n2.1\n\nConstructs a type by picking the set of properties Keys (string literal or union of string literals) from Type.\n\nExample\ninterface Todo {\n  title: string;\n  description: string;\n  completed: boolean;\n}\n \ntype TodoPreview = Pick<Todo, \"title\" | \"completed\">;\n \nconst todo: TodoPreview = {\n  title: \"Clean room\",\n  completed: false,\n};\n \ntodo;\n \nconst todo: TodoPreview\nTry\nOmit<Type, Keys>\nReleased:\n3.5\n\nConstructs a type by picking all properties from Type and then removing Keys (string literal or union of string literals). The opposite of Pick.\n\nExample\ninterface Todo {\n  title: string;\n  description: string;\n  completed: boolean;\n  createdAt: number;\n}\n \ntype TodoPreview = Omit<Todo, \"description\">;\n \nconst todo: TodoPreview = {\n  title: \"Clean room\",\n  completed: false,\n  createdAt: 1615544252770,\n};\n \ntodo;\n \nconst todo: TodoPreview\n \ntype TodoInfo = Omit<Todo, \"completed\" | \"createdAt\">;\n \nconst todoInfo: TodoInfo = {\n  title: \"Pick up kids\",\n  description: \"Kindergarten closes at 5pm\",\n};\n \ntodoInfo;\n   \nconst todoInfo: TodoInfo",
      "id": 10
    }
  ]
}